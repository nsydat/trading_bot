"""
Base Strategy Class
==================

Abstract base class that defines the interface for all trading strategies.
All strategies must inherit from this class and implement its abstract methods.

This provides a consistent interface for strategy execution, signal generation,
and backtesting across different strategy types.

Author: dat-ns
Version: 1.0.0
"""

from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from datetime import datetime
import pandas as pd
import numpy as np
import logging


class StrategyType(Enum):
    """Enumeration of strategy categories."""
    TREND_FOLLOWING = "trend_following"
    MEAN_REVERSION = "mean_reversion" 
    BREAKOUT = "breakout"
    SCALPING = "scalping"
    ARBITRAGE = "arbitrage"
    ML_BASED = "ml_based"
    MULTI_TIMEFRAME = "multi_timeframe"


class SignalType(Enum):
    """Types of trading signals."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


class SignalStrength(Enum):
    """Signal strength levels."""
    WEAK = 1
    MODERATE = 2
    STRONG = 3
    VERY_STRONG = 4


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        type (SignalType): Type of signal (BUY/SELL/HOLD/etc.)
        strength (SignalStrength): Strength of the signal
        price (float): Price at which signal was generated
        timestamp (datetime): When the signal was generated
        confidence (float): Confidence level (0.0 to 1.0)
        metadata (Dict): Additional signal metadata
        stop_loss (Optional[float]): Suggested stop loss level
        take_profit (Optional[float]): Suggested take profit level
        position_size (Optional[float]): Suggested position size (0.0 to 1.0)
    """
    type: SignalType
    strength: SignalStrength
    price: float
    timestamp: datetime
    confidence: float = 0.5
    metadata: Dict[str, Any] = field(default_factory=dict)
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[float] = None
    
    def __post_init__(self):
        """Validate signal parameters after initialization."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")
        
        if self.position_size is not None and not 0.0 < self.position_size <= 1.0:
            raise ValueError("Position size must be between 0.0 and 1.0")


@dataclass 
class BacktestResult:
    """
    Results from strategy backtesting.
    
    Attributes:
        total_return (float): Total return percentage
        sharpe_ratio (float): Sharpe ratio
        max_drawdown (float): Maximum drawdown percentage
        win_rate (float): Percentage of winning trades
        total_trades (int): Total number of trades
        profitable_trades (int): Number of profitable trades
        avg_trade_return (float): Average return per trade
        volatility (float): Strategy volatility
        start_date (datetime): Backtest start date
        end_date (datetime): Backtest end date
        initial_capital (float): Starting capital
        final_capital (float): Ending capital
        trade_log (List[Dict]): Detailed trade log
        performance_metrics (Dict[str, float]): Additional metrics
    """
    total_return: float
    sharpe_ratio: float
    max_drawdown: float
    win_rate: float
    total_trades: int
    profitable_trades: int
    avg_trade_return: float
    volatility: float
    start_date: datetime
    end_date: datetime
    initial_capital: float
    final_capital: float
    trade_log: List[Dict] = field(default_factory=list)
    performance_metrics: Dict[str, float] = field(default_factory=dict)


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    This class defines the interface that all strategies must implement.
    It provides common functionality and enforces consistent behavior
    across different strategy implementations.
    """
    
    # Strategy metadata (to be overridden in subclasses)
    strategy_type: StrategyType = StrategyType.TREND_FOLLOWING
    name: str = "Base Strategy"
    description: str = "Abstract base strategy class"
    version: str = "1.0.0"
    
    def __init__(self, symbol: str = "BTCUSDT", timeframe: str = "15m", **kwargs):
        """
        Initialize the base strategy.
        
        Args:
            symbol (str): Trading symbol (e.g., "BTCUSDT")
            timeframe (str): Timeframe for analysis (e.g., "15m", "1h")
            **kwargs: Additional strategy-specific parameters
        """
        self.symbol = symbol
        self.timeframe = timeframe
        self.logger = logging.getLogger(f"{self.__class__.__name__}")
        
        # Strategy state
        self.is_initialized = False
        self.last_signal: Optional[Signal] = None
        self.current_position: Optional[str] = None  # "long", "short", None
        self.signals_history: List[Signal] = []
        
        # Strategy parameters (to be set by subclasses)
        self.parameters: Dict[str, Any] = {}
        
        # Performance tracking
        self.trades_count = 0
        self.winning_trades = 0
        self.total_pnl = 0.0
        
        # Data storage
        self.market_data: Optional[pd.DataFrame] = None
        self.indicators: Dict[str, pd.Series] = {}
        
        self.logger.info(f"ðŸŽ¯ Initialized {self.name} for {symbol} on {timeframe}")
    
    @abstractmethod
    async def initialize(self) -> bool:
        """
        Initialize the strategy with required indicators and setup.
        
        This method should:
        1. Validate strategy parameters
        2. Initialize required technical indicators
        3. Set up any additional resources
        4. Perform initial calculations
        
        Returns:
            bool: True if initialization successful, False otherwise
        """
        pass
    
    @abstractmethod
    async def generate_signal(self, data: pd.DataFrame) -> Optional[Signal]:
        """
        Generate trading signal based on current market data.
        
        Args:
            data (pd.DataFrame): Market data with OHLCV columns
            
        Returns:
            Optional[Signal]: Generated signal or None if no signal
        """
        pass
    
    @abstractmethod
    def calculate_indicators(self, data: pd.DataFrame) -> Dict[str, pd.Series]:
        """
        Calculate all required technical indicators.
        
        Args:
            data (pd.DataFrame): Market data with OHLCV columns
            
        Returns:
            Dict[str, pd.Series]: Dictionary of calculated indicators
        """
        pass
    
    @abstractmethod
    def validate_signal(self, signal: Signal, data: pd.DataFrame) -> bool:
        """
        Validate a generated signal before execution.
        
        Args:
            signal (Signal): Signal to validate
            data (pd.DataFrame): Current market data
            
        Returns:
            bool: True if signal is valid, False otherwise
        """
        pass
    
    async def update_data(self, data: pd.DataFrame) -> bool:
        """
        Update strategy with new market data.
        
        Args:
            data (pd.DataFrame): New market data
            
        Returns:
            bool: True if update successful, False otherwise
        """
        try:
            self.market_data = data
            
            # Calculate indicators
            self.indicators = self.calculate_indicators(data)
            
            # Generate signal if conditions are met
            signal = await self.generate_signal(data)
            
            if signal and self.validate_signal(signal, data):
                self.last_signal = signal
                self.signals_history.append(signal)
                self.logger.info(
                    f"ðŸ“Š {self.name}: Generated {signal.type.value} signal "
                    f"(strength: {signal.strength.value}, confidence: {signal.confidence:.2f})"
                )
                return True
            
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ Error updating strategy data: {e}")
            return False
    
    def get_current_signal(self) -> Optional[Signal]:
        """
        Get the most recent signal generated by the strategy.
        
        Returns:
            Optional[Signal]: Most recent signal or None
        """
        return self.last_signal
    
    def get_signals_history(self, limit: Optional[int] = None) -> List[Signal]:
        """
        Get history of signals generated by the strategy.
        
        Args:
            limit (Optional[int]): Maximum number of signals to return
            
        Returns:
            List[Signal]: List of historical signals
        """
        if limit is None:
            return self.signals_history.copy()
        return self.signals_history[-limit:]
    
    def get_parameters(self) -> Dict[str, Any]:
        """
        Get strategy parameters.
        
        Returns:
            Dict[str, Any]: Dictionary of strategy parameters
        """
        return self.parameters.copy()
    
    def set_parameters(self, parameters: Dict[str, Any]):
        """
        Update strategy parameters.
        
        Args:
            parameters (Dict[str, Any]): New parameter values
        """
        self.parameters.update(parameters)
        self.logger.info(f"ðŸ“ Updated {self.name} parameters: {parameters}")
    
    def calculate_position_size(self, signal: Signal, account_balance: float, 
                              risk_per_trade: float = 0.02) -> float:
        """
        Calculate position size based on risk management rules.
        
        Args:
            signal (Signal): Trading signal
            account_balance (float): Current account balance
            risk_per_trade (float): Risk per trade as percentage of balance
            
        Returns:
            float: Position size in base currency
        """
        if signal.stop_loss is None:
            # Default to 2% risk if no stop loss specified
            return account_balance * risk_per_trade
        
        # Calculate position size based on stop loss distance
        stop_loss_distance = abs(signal.price - signal.stop_loss) / signal.price
        risk_amount = account_balance * risk_per_trade
        
        if stop_loss_distance > 0:
            position_size = risk_amount / stop_loss_distance
            return min(position_size, account_balance * 0.95)  # Max 95% of balance
        
        return account_balance * risk_per_trade
    
    async def backtest(self, historical_data: pd.DataFrame, 
                      initial_capital: float = 10000.0,
                      commission: float = 0.001) -> BacktestResult:
        """
        Backtest the strategy on historical data.
        
        Args:
            historical_data (pd.DataFrame): Historical OHLCV data
            initial_capital (float): Starting capital for backtest
            commission (float): Commission rate per trade
            
        Returns:
            BacktestResult: Comprehensive backtest results
        """
        self.logger.info(f"ðŸ”„ Starting backtest for {self.name}...")
        
        # Initialize backtest variables
        capital = initial_capital
        position = None
        position_size = 0.0
        entry_price = 0.0
        trades = []
        equity_curve = []
        
        # Initialize strategy
        await self.initialize()
        
        try:
            for i in range(len(historical_data)):
                current_data = historical_data.iloc[:i+1]
                
                if len(current_data) < 50:  # Need minimum data for indicators
                    equity_curve.append(capital)
                    continue
                
                # Update strategy with current data
                await self.update_data(current_data)
                signal = self.get_current_signal()
                
                current_price = current_data.iloc[-1]['close']
                timestamp = current_data.index[-1]
                
                # Process signals
                if signal and signal.timestamp == timestamp:
                    if signal.type == SignalType.BUY and position is None:
                        # Enter long position
                        position = "long"
                        position_size = self.calculate_position_size(
                            signal, capital, risk_per_trade=0.02
                        )
                        entry_price = current_price
                        capital -= commission * position_size
                        
                    elif signal.type == SignalType.SELL and position == "long":
                        # Exit long position
                        pnl = (current_price - entry_price) * position_size / entry_price
                        capital += pnl - (commission * position_size)
                        
                        # Record trade
                        trade = {
                            'entry_time': timestamp,
                            'exit_time': timestamp,
                            'entry_price': entry_price,
                            'exit_price': current_price,
                            'position_size': position_size,
                            'pnl': pnl,
                            'return_pct': (current_price - entry_price) / entry_price * 100
                        }
                        trades.append(trade)
                        
                        position = None
                        position_size = 0.0
                
                # Calculate current equity
                if position == "long":
                    unrealized_pnl = (current_price - entry_price) * position_size / entry_price
                    current_equity = capital + unrealized_pnl
                else:
                    current_equity = capital
                
                equity_curve.append(current_equity)
            
            # Calculate backtest metrics
            equity_series = pd.Series(equity_curve)
            returns = equity_series.pct_change().dropna()
            
            total_return = (equity_series.iloc[-1] - initial_capital) / initial_capital * 100
            sharpe_ratio = np.sqrt(252) * returns.mean() / returns.std() if len(returns) > 0 else 0
            max_drawdown = ((equity_series.cummax() - equity_series) / equity_series.cummax()).max() * 100
            
            profitable_trades = len([t for t in trades if t['pnl'] > 0])
            win_rate = profitable_trades / len(trades) * 100 if trades else 0
            avg_trade_return = np.mean([t['return_pct'] for t in trades]) if trades else 0
            volatility = returns.std() * np.sqrt(252) * 100 if len(returns) > 0 else 0
            
            result = BacktestResult(
                total_return=total_return,
                sharpe_ratio=sharpe_ratio,
                max_drawdown=max_drawdown,
                win_rate=win_rate,
                total_trades=len(trades),
                profitable_trades=profitable_trades,
                avg_trade_return=avg_trade_return,
                volatility=volatility,
                start_date=historical_data.index[0],
                end_date=historical_data.index[-1],
                initial_capital=initial_capital,
                final_capital=equity_series.iloc[-1],
                trade_log=trades,
                performance_metrics={
                    'profit_factor': self._calculate_profit_factor(trades),
                    'max_consecutive_losses': self._calculate_max_consecutive_losses(trades),
                    'average_holding_time': self._calculate_avg_holding_time(trades)
                }
            )
            
            self.logger.info(f"âœ… Backtest completed for {self.name}")
            self.logger.info(f"ðŸ“Š Total Return: {total_return:.2f}%")
            self.logger.info(f"ðŸ“Š Win Rate: {win_rate:.1f}%")
            self.logger.info(f"ðŸ“Š Sharpe Ratio: {sharpe_ratio:.2f}")
            
            return result
            
        except Exception as e:
            self.logger.error(f"âŒ Backtest failed: {e}")
            raise
    
    def _calculate_profit_factor(self, trades: List[Dict]) -> float:
        """Calculate profit factor from trade history."""
        if not trades:
            return 0.0
        
        profits = sum(t['pnl'] for t in trades if t['pnl'] > 0)
        losses = abs(sum(t['pnl'] for t in trades if t['pnl'] < 0))
        
        return profits / losses if losses > 0 else float('inf')
    
    def _calculate_max_consecutive_losses(self, trades: List[Dict]) -> int:
        """Calculate maximum consecutive losing trades."""
        if not trades:
            return 0
        
        max_consecutive = 0
        current_consecutive = 0
        
        for trade in trades:
            if trade['pnl'] < 0:
                current_consecutive += 1
                max_consecutive = max(max_consecutive, current_consecutive)
            else:
                current_consecutive = 0
        
        return max_consecutive
    
    def _calculate_avg_holding_time(self, trades: List[Dict]) -> float:
        """Calculate average holding time in hours."""
        if not trades:
            return 0.0
        
        holding_times = []
        for trade in trades:
            if 'entry_time' in trade and 'exit_time' in trade:
                holding_time = (trade['exit_time'] - trade['entry_time']).total_seconds() / 3600
                holding_times.append(holding_time)
        
        return np.mean(holding_times) if holding_times else 0.0
    
    def get_status(self) -> Dict[str, Any]:
        """
        Get current strategy status and statistics.
        
        Returns:
            Dict[str, Any]: Strategy status information
        """
        return {
            'name': self.name,
            'type': self.strategy_type.value,
            'symbol': self.symbol,
            'timeframe': self.timeframe,
            'is_initialized': self.is_initialized,
            'current_position': self.current_position,
            'last_signal': {
                'type': self.last_signal.type.value if self.last_signal else None,
                'strength': self.last_signal.strength.value if self.last_signal else None,
                'confidence': self.last_signal.confidence if self.last_signal else None,
                'timestamp': self.last_signal.timestamp.isoformat() if self.last_signal else None
            },
            'signals_count': len(self.signals_history),
            'trades_count': self.trades_count,
            'winning_trades': self.winning_trades,
            'win_rate': self.winning_trades / self.trades_count * 100 if self.trades_count > 0 else 0,
            'total_pnl': self.total_pnl,
            'parameters': self.parameters
        }
    
    def __repr__(self) -> str:
        """String representation of the strategy."""
        return f"{self.__class__.__name__}(symbol='{self.symbol}', timeframe='{self.timeframe}')"